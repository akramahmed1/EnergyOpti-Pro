from fastapi import FastAPI, Form, HTTPException, Header
from fastapi.staticfiles import StaticFiles
import tensorflow as tf
import numpy as np
from collections import deque
import logging
from datetime import datetime, timedelta
import threading
import os

app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
VALID_TOKEN = "a1009144b7a5520439407190f9064793"
logging.basicConfig(level=logging.ERROR, filename="app.log")

# Rate limiter decorator
rate_limit_window = 60  # seconds
rate_limit_max_calls = 10
request_counts = {}
lock = threading.Lock()

def rate_limit():
    def decorator(func):
        async def wrapper(*args, authorization: str = Header(None), **kwargs):
            token = authorization.split(" ")[1] if authorization and authorization.startswith("Bearer ") else "unauth"
            worker_key = f"{token}:{os.getpid()}"  # Unique per worker
            if token == VALID_TOKEN:
                with lock:
                    current_time = datetime.utcnow()
                    if worker_key not in request_counts:
                        request_counts[worker_key] = {"start_time": current_time, "count": 0}
                    if (current_time - request_counts[worker_key]["start_time"]) >= timedelta(seconds=rate_limit_window):
                        request_counts[worker_key] = {"start_time": current_time, "count": 0}
                    if request_counts[worker_key]["count"] >= rate_limit_max_calls:
                        raise HTTPException(status_code=429, detail="Rate limit exceeded")
                    request_counts[worker_key]["count"] += 1
            return await func(*args, authorization=authorization, **kwargs)
        return wrapper
    return decorator

interpreter = tf.lite.Interpreter(model_path="optimized_model.tflite")
interpreter.allocate_tensors()
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()
history = deque(maxlen=5)

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

@app.get("/")
async def home():
    return {"message": "Welcome to Energy Opti"}

@app.get("/static/index.html", include_in_schema=False)
async def serve_index():
    return StaticFiles(directory="static").serve("index.html")

@app.post("/predict")
@rate_limit()
async def predict(value: float = Form(...), authorization: str = Header(None)):
    token = authorization.split(" ")[1] if authorization and authorization.startswith("Bearer ") else "unauth"
    if not authorization or not authorization.startswith("Bearer ") or token != VALID_TOKEN:
        raise HTTPException(status_code=401, detail="Invalid token")
    try:
        input_data = np.array([[value]], dtype=np.float32)
        interpreter.set_tensor(input_details[0]['index'], input_data)
        interpreter.invoke()
        prediction = float(interpreter.get_tensor(output_details[0]['index'])[0][0])
        history.append((value, prediction))
        return {"prediction": prediction, "history": list(history)}
    except ValueError as ve:
        logging.error(f"ValueError: {ve}")
        return {"error": "Invalid input", "detail": str(ve)}
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        return {"error": "Server error", "detail": str(e)}

if __name__ == "__main__":
    import uvicorn

